import { OAuth2 } from 'oauth'
import axios from 'axios'

import StreamListener from './stream_listener'

import OAuth from './oauth'
const NO_REDIRECT = 'urn:ietf:wg:oauth:2.0:oob'
const DEFAULT_URL = 'https://mastodon.social'
const DEFAULT_SCOPE = 'read write follow'

/**
 * for Mastodon API
 *
 * using superagent for request, you will handle promises
 */
class Mastodon {
  static DEFAULT_SCOPE = DEFAULT_SCOPE
  static DEFAULT_URL = DEFAULT_URL
  static NO_REDIRECT = NO_REDIRECT

  private accessToken: string
  private baseUrl: string

  /**
   * @param accessToken access token from OAuth2 authorization
   * @param baseUrl hostname or base URL
   */
  constructor(accessToken: string, baseUrl = DEFAULT_URL) {
    this.accessToken = accessToken
    this.baseUrl = baseUrl
  }

  /**
   * unauthorized GET request to mastodon REST API
   * @param path relative path from ${baseUrl}/api/v1/ or absolute path
   * @param params Query parameters
   * @param baseUrl base URL of the target
   */
  public static get(path: string, params = {}, baseUrl = DEFAULT_URL): Promise<object> {
    const apiUrl = baseUrl
    return axios
      .get(apiUrl + path, {
        params
      })
      .then(resp => resp.data)
  }

  private static _post(path: string, params = {}, baseUrl = DEFAULT_URL): Promise<object> {
    const apiUrl = baseUrl
    return axios
      .post(apiUrl + path, params)
      .then(resp => resp.data)
  }

  /**
   * Wrapper for personal OAuth Application (createApp and generateAuthUrl)
   *
   * First, [POST /api/v1/apps](https://github.com/tootsuite/documentation/blob/master/Using-the-API/API.md#apps)
   * only client_name is required, so others are optional.
   * Secound, generate an authorization url.
   * finally, return promise of OAuth.AppData instance, which has client_id, client_secret, url, and so on.
   * @param client_name Form Data, which is sent to /api/v1/apps
   * @param options Form Data, which is sent to /api/v1/apps. and properties should be **snake_case**
   * @param baseUrl base URL of the target
   */
  public static registerApp(
    client_name: string,
    options: Partial<{ scopes: string, redirect_uris: string, website: string }> = {
      scopes: DEFAULT_SCOPE,
      redirect_uris: NO_REDIRECT
    },
    baseUrl = DEFAULT_URL
  ): Promise<OAuth.AppData> {
    return this.createApp(client_name, options, baseUrl)
      .then(appData => {
        return this.generateAuthUrl(appData.client_id, appData.client_secret, {
          redirect_uri: NO_REDIRECT,
          scope: options.scopes
        }, baseUrl)
          .then(url => {
            appData.url = url
            return appData
          })
      })
  }


  /**
   * Create an application
   *
   * First, [POST /api/v1/apps](https://github.com/tootsuite/documentation/blob/master/Using-the-API/API.md#apps)
   * @param client_name your application's name
   * @param options Form Data
   * @param baseUrl target of base URL
   */
  public static createApp(
    client_name: string,
    options: Partial<{ redirect_uris: string, scopes: string, website: string }> = {
      redirect_uris: NO_REDIRECT,
      scopes: DEFAULT_SCOPE
    },
    baseUrl = DEFAULT_URL
  ): Promise<OAuth.AppData> {
    const redirect_uris = options.redirect_uris || NO_REDIRECT
    const scopes = options.scopes || DEFAULT_SCOPE

    const params: {
      client_name: string,
      redirect_uris: string,
      scopes: string,
      website?: string
    } = {
      client_name,
      redirect_uris,
      scopes
    }
    if (options.website) params.website = options.website

    return this._post('/api/v1/apps', params, baseUrl)
      .then(data => OAuth.AppData.from(data as OAuth.AppDataFromServer))
  }

  /**
   * generate authorization url
   *
   * @param clientId your OAuth app's client ID
   * @param clientSecret your OAuth app's client Secret
   * @param options as property, redirect_uri and scope are available, and must be the same as when you register your app
   * @param baseUrl base URL of the target
   */
  public static generateAuthUrl(
    clientId: string,
    clientSecret: string,
    options: Partial<{ redirect_uri: string, scope: string }> = {
      redirect_uri: NO_REDIRECT,
      scope: DEFAULT_SCOPE
    },
    baseUrl = DEFAULT_URL
  ): Promise<string> {
    return new Promise((resolve) => {
      const oauth = new OAuth2(clientId, clientSecret, baseUrl, undefined, '/oauth/token')
      const url = oauth.getAuthorizeUrl({
        redirect_uri: options.redirect_uri,
        response_type: 'code',
        client_id: clientId,
        scope: options.scope
      })
      resolve(url)
    })
  }

  /**
   * Fetch OAuth access token
   * @param client_id will be generated by #createApp or #registerApp
   * @param client_secret will be generated by #createApp or #registerApp
   * @param code will be generated by the link of #generateAuthUrl or #registerApp
   * @param baseUrl base URL of the target
   * @param redirect_uri must be the same uri as the time when you register your OAuth application
   */
  public static fetchAccessToken(
    client_id: string,
    client_secret: string,
    code: string,
    baseUrl = DEFAULT_URL,
    redirect_uri = NO_REDIRECT
  ): Promise<OAuth.TokenData> {
    return this._post('/oauth/token', {
      client_id,
      client_secret,
      code,
      redirect_uri,
      grant_type: 'authorization_code'
    }, baseUrl).then(data => OAuth.TokenData.from(data as OAuth.TokenDataFromServer))
  }

  /**
   * GET request to mastodon REST API
   * @param path relative path from ${baseUrl}/api/v1/ or absolute path
   * @param params Query parameters
   */
  public get<T>(path: string, params = {}): Promise<T> {
    return axios
      .get(this.baseUrl + path, {
        headers: {
          'Authorization': `Bearer ${this.accessToken}`
        },
        params
      })
      .then(resp => resp.data as T)
  }

  /**
   * PATCH request to mastodon REST API
   * @param path relative path from ${baseUrl}/api/v1/ or absolute path
   * @param params Form data
   */
  public patch<T>(path: string, params = {}): Promise<T> {
    return axios
      .patch(this.baseUrl + path, params, {
        headers: {
          'Authorization': `Bearer ${this.accessToken}`
        }
      })
      .then(resp => resp.data as T)
  }

  /**
   * POST request to mastodon REST API
   * @param path relative path from ${baseUrl}/api/v1/ or absolute path
   * @param params Form data
   */
  public post<T>(path: string, params = {}): Promise<T> {
    return axios
      .post(this.baseUrl + path, params, {
        headers: {
          'Authorization': `Bearer ${this.accessToken}`
        }
      })
      .then(resp => resp.data as T)
  }

  /**
   * DELETE request to mastodon REST API
   * @param path relative path from ${baseUrl}/api/v1/ or absolute path
   */
  public del(path: string): Promise<{}> {
    return axios
      .delete(this.baseUrl + path, {
        headers: {
          'Authorization': `Bearer ${this.accessToken}`
        }
      })
      .then(resp => resp.data as {})
  }

  /**
   * receive Server-sent Events from Mastodon Streaming API
   * @param path relative path from ${baseUrl}/api/v1/streaming/ or absolute path
   *             'public', 'public/local', 'user' and 'hashtag?tag=${tag}' are available.
   * @param reconnectInterval interval of reconnect
   * @returns streamListener, which inherits from EventEmitter and has event, 'update', 'notification', 'delete', and so on.
   */
  public stream(path: string, reconnectInterval = 1000): StreamListener {
    const headers = {
      'Cache-Control': 'no-cache',
      'Accept': 'text/event-stream',
      'Authorization': `Bearer ${this.accessToken}`
    }
    const url = this.baseUrl + path
    const streaming = new StreamListener(url, headers, reconnectInterval)
    process.nextTick(() => {
      streaming.start()
    })
    return streaming
  }
}

module.exports = Mastodon
