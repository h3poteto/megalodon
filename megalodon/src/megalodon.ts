import Response from './response'
import OAuth from './oauth'
import Pleroma from './pleroma'
import { ProxyConfig } from './proxy_config'
import Mastodon from './mastodon'
import Entity from './entity'
import Friendica from './friendica'
import Firefish from './firefish'

export interface WebSocketInterface {
  start(): void
  stop(): void
  // EventEmitter
  on(event: string | symbol, listener: (...args: any[]) => void): this
  once(event: string | symbol, listener: (...args: any[]) => void): this
  removeListener(event: string | symbol, listener: (...args: any[]) => void): this
  removeAllListeners(event?: string | symbol): this
}

export interface MegalodonInterface {
  /**
   * Cancel all requests in this instance.
   *
   * @return void
   */
  cancel(): void

  /**
   * First, call createApp to get client_id and client_secret.
   * Next, call generateAuthUrl to get authorization url.
   *
   * @param client_name Form Data, which is sent to /api/v1/apps
   * @param options Form Data, which is sent to /api/v1/apps. and properties should be **snake_case**
   */
  registerApp(
    client_name: string,
    options: Partial<{ scopes: Array<string>; redirect_uris: string; website: string }>
  ): Promise<OAuth.AppData>

  /**
   * Create an application.
   *
   * @param client_name your application's name
   * @param options Form Data
   */
  createApp(
    client_name: string,
    options: Partial<{ scopes: Array<string>; redirect_uris: string; website: string }>
  ): Promise<OAuth.AppData>

  // ======================================
  // apps
  // ======================================
  /**
   * Verify the app works.
   *
   * @return An Application
   */
  verifyAppCredentials(): Promise<Response<Entity.Application>>

  // ======================================
  // apps/oauth
  // ======================================
  /**
   * Fetch OAuth access token.
   * Get an access token based client_id and client_secret and authorization code.
   *
   * @param client_id will be generated by #createApp or #registerApp
   * @param client_secret will be generated by #createApp or #registerApp
   * @param code will be generated by the link of #generateAuthUrl or #registerApp
   * @param redirect_uri must be the same uri as the time when you register your OAuth application
   */
  fetchAccessToken(client_id: string | null, client_secret: string, code: string, redirect_uri?: string): Promise<OAuth.TokenData>

  /**
   * Refresh OAuth access token.
   * Send refresh token and get new access token.
   *
   * @param client_id will be generated by #createApp or #registerApp
   * @param client_secret will be generated by #createApp or #registerApp
   * @param refresh_token will be get #fetchAccessToken
   */
  refreshToken(client_id: string, client_secret: string, refresh_token: string): Promise<OAuth.TokenData>

  /**
   * Revoke an OAuth token.
   *
   * @param client_id will be generated by #createApp or #registerApp
   * @param client_secret will be generated by #createApp or #registerApp
   * @param token will be get #fetchAccessToken
   */
  revokeToken(client_id: string, client_secret: string, token: string): Promise<Response<{}>>

  // ======================================
  // accounts
  // ======================================
  /**
   * Creates a user and account records. Returns an account access token for the app that initiated the request. The app should save this token for later, and should wait for the user to confirm their account by clicking a link in their email inbox.
   *
   * @param username Username for the account.
   * @param email Email for the account.
   * @param password Password for the account.
   * @param agreement Whether the user agrees to the local rules, terms, and policies.
   * @param locale The language of the confirmation email that will be sent
   * @param reason Text that will be reviewed by moderators if registrations require manual approval.
   * @return An account token.
   */
  registerAccount(
    username: string,
    email: string,
    password: string,
    agreement: boolean,
    locale: string,
    reason?: string | null
  ): Promise<Response<Entity.Token>>
  /**
   * Test to make sure that the user token works.
   *
   * @return Account.
   */
  verifyAccountCredentials(): Promise<Response<Entity.Account>>
  /**
   * Update the userâ€™s display and preferences.
   *
   * @param options.discoverable Whether the account should be shown in the profile directory.
   * @param options.bot Whether the account has a bot flag.
   * @param options.display_name The display name to use for the profile.
   * @param options.note The account bio.
   * @param options.avatar Avatar image encoded using multipart/form-data.
   * @param options.header Header image encoded using multipart/form-data.
   * @param options.locked Whether manual approval of follow requests is required.
   * @param options.source.privacy Default post privacy for authored statuses. Can be public, unlisted, or private.
   * @param options.source.sensitive Whether to mark authored statuses as sensitive by default.
   * @param options.source.language Default language to use for authored statuses (ISO 6391).
   * @param options.fields_attributes The profile fields to be set. Inside this hash, the key is an integer cast to a string (although the exact integer does not matter), and the value is another hash including name and value. By default, max 4 fields.
   * @return An account.
   */
  updateCredentials(options?: {
    discoverable?: boolean
    bot?: boolean
    display_name?: string
    note?: string
    avatar?: string
    header?: string
    locked?: boolean
    source?: {
      privacy?: string
      sensitive?: boolean
      language?: string
    }
    fields_attributes?: Array<{ name: string; value: string }>
  }): Promise<Response<Entity.Account>>
  /**
   * View information about a profile.
   *
   * @param id The account ID.
   * @return An account.
   */
  getAccount(id: string): Promise<Response<Entity.Account>>
  /**
   * Statuses posted to the given account.
   *
   * @param id The account ID.
   * @param options.limit Max number of results to return. Defaults to 20.
   * @param options.max_id Return results older than ID.
   * @param options.since_id Return results newer than ID but starting with most recent.
   * @param options.min_id Return results newer than ID.
   * @param options.pinned Return statuses which include pinned statuses.
   * @param options.exclude_replies Return statuses which exclude replies.
   * @param options.exclude_reblogs Return statuses which exclude reblogs.
   * @param options.only_media Show only statuses with media attached? Defaults to false.
   * @return Account's statuses.
   */
  getAccountStatuses(
    id: string,
    options?: {
      limit?: number
      max_id?: string
      since_id?: string
      min_id?: string
      pinned?: boolean
      exclude_replies?: boolean
      exclude_reblogs?: boolean
      only_media?: boolean
    }
  ): Promise<Response<Array<Entity.Status>>>
  /**
   * Favourites timeline of any user.
   *
   * @param id Target account ID.
   * @param options.limit Max number of results to return.
   * @param options.max_id Return results order than ID.
   * @param options.since_id Return results newer than ID.
   * @return Array of statuses.
   */
  getAccountFavourites(
    id: string,
    options?: {
      limit?: number
      max_id?: string
      since_id?: string
    }
  ): Promise<Response<Array<Entity.Status>>>
  /**
   * Subscribe to receive notifications for all statuses posted by a user.
   *
   * @param id Target account ID.
   * @return Relationship.
   */
  subscribeAccount(id: string): Promise<Response<Entity.Relationship>>
  /**
   * Unsubscribe to stop receiving notifications from user statuses.
   *
   * @param id Target account ID.
   * @return Relationship.
   */
  unsubscribeAccount(id: string): Promise<Response<Entity.Relationship>>
  /**
   * Accounts which follow the given account, if network is not hidden by the account owner.
   *
   * @param id The account ID.
   * @param options.limit Max number of results to return. Defaults to 40.
   * @param options.max_id Return results older than ID.
   * @param options.since_id Return results newer than ID.
   * @param options.get_all
   * @param options.sleep_ms
   * @return The array of accounts.
   */
  getAccountFollowers(
    id: string,
    options?: {
      limit?: number
      max_id?: string
      since_id?: string
      get_all?: boolean
      sleep_ms?: number
    }
  ): Promise<Response<Array<Entity.Account>>>
  /**
   * Accounts which the given account is following, if network is not hidden by the account owner.
   *
   * @param id The account ID.
   * @param options.limit Max number of results to return. Defaults to 40.
   * @param options.max_id Return results older than ID.
   * @param options.since_id Return results newer than ID.
   * @param options.get_all
   * @param options.sleep_ms
   * @return The array of accounts.
   */
  getAccountFollowing(
    id: string,
    options?: {
      limit?: number
      max_id?: string
      since_id?: string
      get_all?: boolean
      sleep_ms?: number
    }
  ): Promise<Response<Array<Entity.Account>>>
  /**
   * User lists that you have added this account to.
   *
   * @param id The account ID.
   * @return The array of lists.
   */
  getAccountLists(id: string): Promise<Response<Array<Entity.List>>>
  /**
   * Returns an IdentityProof.
   *
   * @param id The account ID.
   * @return Array of IdentityProof
   */
  getIdentityProof(id: string): Promise<Response<Array<Entity.IdentityProof>>>
  /**
   * Follow the given account. Can also be used to update whether to show reblogs or enable notifications.
   *
   * @param id The account ID.
   * @param reblog Receive this account's reblogs in home timeline.
   * @return Relationship
   */
  followAccount(
    id: string,
    options?: {
      reblog?: boolean
    }
  ): Promise<Response<Entity.Relationship>>
  /**
   * Unfollow the given account.
   *
   * @param id The account ID.
   * @return Relationship
   */
  unfollowAccount(id: string): Promise<Response<Entity.Relationship>>
  /**
   * lock the given account. Clients should filter statuses from this account if received.
   *
   * @param id The account ID.
   * @return Relationship
   */
  blockAccount(id: string): Promise<Response<Entity.Relationship>>
  /**
   * Unblock the given account.
   *
   * @param id The account ID.
   * @return RElationship
   */
  unblockAccount(id: string): Promise<Response<Entity.Relationship>>
  /**
   * Mute the given account. Clients should filter statuses and notifications from this account, if received,
   *
   * @param id The account ID.
   * @param notifications Mute notifications in addition to statuses.
   * @return Relationship
   */
  muteAccount(id: string, notifications: boolean): Promise<Response<Entity.Relationship>>
  /**
   * Unmute the given account.
   *
   * @param id The account ID.
   * @return Relationship
   */
  unmuteAccount(id: string): Promise<Response<Entity.Relationship>>
  /**
   * Add the given account to the userâ€™s featured profiles.
   *
   * @param id The account ID.
   * @return Relationship
   */
  pinAccount(id: string): Promise<Response<Entity.Relationship>>
  /**
   * Remove the given account from the userâ€™s featured profiles.
   *
   * @param id The account ID.
   * @return Relationship
   */
  unpinAccount(id: string): Promise<Response<Entity.Relationship>>
  /**
   * Find out whether a given account is followed, blocked, muted, etc.
   *
   * @param id The account ID.
   * @return Relationship
   */
  getRelationship(id: string): Promise<Response<Entity.Relationship>>
  /**
   * Find out whether given accounts are followed, blocked, muted, etc.
   *
   * @param ids Array of account IDs.
   * @return Array of Relationship.
   */
  getRelationships(ids: Array<string>): Promise<Response<Array<Entity.Relationship>>>
  /**
   * Search for matching accounts by username or display name.
   *
   * @param q Search query.
   * @param options.limit Max number of results to return. Defaults to 40.
   * @param options.max_id Return results older than ID.
   * @param options.since_id Return results newer than ID.
   * @return The array of accounts.
   */
  searchAccount(
    q: string,
    options?: {
      following?: boolean
      resolve?: boolean
      limit?: number
      max_id?: string
      since_id?: string
    }
  ): Promise<Response<Array<Entity.Account>>>
  // ======================================
  // accounts/bookmarks
  // ======================================
  /**
   * Statuses the user has bookmarked.
   *
   * @param options.limit Max number of results to return. Defaults to 40.
   * @param options.max_id Return results older than ID.
   * @param options.since_id Return results newer than ID.
   * @param options.min_id Return results immediately newer than ID.
   * @return Array of statuses.
   */
  getBookmarks(options?: { limit?: number; max_id?: string; since_id?: string; min_id?: string }): Promise<Response<Array<Entity.Status>>>
  // ======================================
  //  accounts/favourites
  // ======================================
  /**
   * Statuses the user has favourited.
   *
   * @param options.limit Max number of results to return. Defaults to 40.
   * @param options.max_id Return results older than ID.
   * @param options.min_id Return results immediately newer than ID.
   * @return Array of statuses.
   */
  getFavourites(options?: { limit?: number; max_id?: string; min_id?: string }): Promise<Response<Array<Entity.Status>>>
  // ======================================
  // accounts/mutes
  // ======================================
  /**
   * Accounts the user has muted.
   *
   * @param options.limit Max number of results to return. Defaults to 40.
   * @param options.max_id Return results older than ID.
   * @param options.min_id Return results immediately newer than ID.
   * @return Array of accounts.
   */
  getMutes(options?: { limit?: number; max_id?: string; min_id?: string }): Promise<Response<Array<Entity.Account>>>
  // ======================================
  // accounts/blocks
  // ======================================
  /**
   * View blocked users.
   *
   * @param options.limit Max number of results to return. Defaults to 40.
   * @param options.max_id Return results older than ID.
   * @param options.min_id Return results immediately newer than ID.
   * @return Array of accounts.
   */
  getBlocks(options?: { limit?: number; max_id?: string; min_id?: string }): Promise<Response<Array<Entity.Account>>>
  // ======================================
  // accounts/domain_blocks
  // ======================================
  /**
   * View domains the user has blocked.
   *
   * @param options.limit Max number of results to return. Defaults to 40.
   * @param options.max_id Return results older than ID.
   * @param options.min_id Return results immediately newer than ID.
   * @return Array of domain name.
   */
  getDomainBlocks(options?: { limit?: number; max_id?: string; min_id?: string }): Promise<Response<Array<string>>>
  /**
   * Block a domain.
   *
   * @param domain Domain to block.
   */
  blockDomain(domain: string): Promise<Response<{}>>
  /**
   * Remove a domain block, if it exists in the userâ€™s array of blocked domains.
   *
   * @param domain Domain to unblock
   */
  unblockDomain(domain: string): Promise<Response<{}>>
  // ======================================
  // accounts/filters
  // ======================================
  /**
   * Get filters of the current user.
   *
   * @return Array of filters.
   */
  getFilters(): Promise<Response<Array<Entity.Filter>>>
  /**
   * Get a specyfic filter.
   *
   * @param id The filter ID.
   * @return Filter.
   */
  getFilter(id: string): Promise<Response<Entity.Filter>>
  /**
   * Create a filter.
   *
   * @param phrase Text to be filtered.
   * @param context Array of enumerable strings home, notifications, public, thread, account. At least one context must be specified.
   * @param options.irreversible Should the server irreversibly drop matching entities from home and notifications?
   * @param options.whole_word Consider word boundaries?
   * @param options.expires_in ISO 8601 Datetime for when the filter expires.
   * @return Filter
   */
  createFilter(
    phrase: string,
    context: Array<Entity.FilterContext>,
    options?: {
      irreversible?: boolean
      whole_word?: boolean
      expires_in?: string
    }
  ): Promise<Response<Entity.Filter>>
  /**
   * Replaces a filterâ€™s parameters in-place.
   *
   * @param id The filter ID.
   * @param phrase Text to be filtered.
   * @param context Array of enumerable strings home, notifications, public, thread, account. At least one context must be specified.
   * @param options.irreversible Should the server irreversibly drop matching entities from home and notifications?
   * @param options.whole_word Consider word boundaries?
   * @param options.expires_in ISO 8601 Datetime for when the filter expires.
   * @return Filter
   */
  updateFilter(
    id: string,
    phrase: string,
    context: Array<Entity.FilterContext>,
    options?: {
      irreversible?: boolean
      whole_word?: boolean
      expires_in?: string
    }
  ): Promise<Response<Entity.Filter>>
  /**
   * Remove a filter.
   *
   * @param id The filter ID.
   * @return Removed filter.
   */
  deleteFilter(id: string): Promise<Response<Entity.Filter>>
  // ======================================
  // accounts/reports
  // ======================================
  /**
   * File a report.
   *
   * @param account_id Target account ID.
   * @param options.status_ids Array of Statuses ids to attach to the report.
   * @param options.comment The reason for the report. Default maximum of 1000 characters.
   * @param options.forward If the account is remote, should the report be forwarded to the remote admin?
   * @param options.category Specify if the report is due to spam, violation of enumerated instance rules, or some other reason. Defaults to other. Will be set to violation if rule_ids[] is provided (regardless of any category value you provide).
   * @param options.rule_ids For violation category reports, specify the ID of the exact rules broken. Rules and their IDs are available via GET /api/v1/instance/rules and GET /api/v1/instance.
   * @return Report
   */
  report(
    account_id: string,
    options?: {
      status_ids?: Array<string>
      comment: string
      forward?: boolean
      category?: Entity.Category
      rule_ids?: Array<number>
    }
  ): Promise<Response<Entity.Report>>
  // ======================================
  // accounts/follow_requests
  // ======================================
  /**
   * Get pending follow requests.
   *
   * @param limit Maximum number of results.
   * @return Array of account or follow request.
   */
  getFollowRequests(limit?: number): Promise<Response<Array<Entity.Account | Entity.FollowRequest>>>
  /**
   * Accept the follow request.
   *
   * @param id Target account ID. Or follow request ID in Friendica.
   * @return Relationship.
   */
  acceptFollowRequest(id: string): Promise<Response<Entity.Relationship>>
  /**
   * Reject the follow request.
   *
   * @param id Target account ID. Or follow request ID in Friendica.
   * @return Relationship.
   */
  rejectFollowRequest(id: string): Promise<Response<Entity.Relationship>>
  // ======================================
  // accounts/endorsements
  // ======================================
  /**
   * Accounts that the user is currently featuring on their profile.
   *
   * @param options.limit Max number of results to return. Defaults to 40.
   * @param options.max_id Return results older than ID.
   * @param options.since_id Return results newer than ID.
   * @return Array of accounts.
   */
  getEndorsements(options?: { limit?: number; max_id?: string; since_id?: string }): Promise<Response<Array<Entity.Account>>>
  // ======================================
  // accounts/featured_tags
  // ======================================
  /**
   * List all hashtags featured on your profile.
   *
   * @return Array of featured tag.
   */
  getFeaturedTags(): Promise<Response<Array<Entity.FeaturedTag>>>
  /**
   * Promote a hashtag on your profile.
   *
   * @param name Target hashtag name.
   * @return FeaturedTag.
   */
  createFeaturedTag(name: string): Promise<Response<Entity.FeaturedTag>>
  /**
   * Stop promoting a hashtag on your profile.
   *
   * @param id Target featured tag id.
   * @return Empty
   */
  deleteFeaturedTag(id: string): Promise<Response<{}>>
  /**
   * Shows up to 10 recently-used tags.
   *
   * @return Array of tag.
   */
  getSuggestedTags(): Promise<Response<Array<Entity.Tag>>>
  // ======================================
  // accounts/preferences
  // ======================================
  /**
   * Get preferences defined by the user in their account settings.
   *
   * @return Preferences.
   */
  getPreferences(): Promise<Response<Entity.Preferences>>
  // ======================================
  // accounts/followed_tags
  // ======================================
  /**
   * View all followed tags.
   *
   * @return Array of tag.
   */
  getFollowedTags(): Promise<Response<Array<Entity.Tag>>>
  // ======================================
  // accounts/suggestions
  // ======================================
  /**
   * Accounts the user has had past positive interactions with, but is not yet following.
   *
   * @param limit Maximum number of results.
   * @return Array of accounts.
   */
  getSuggestions(limit?: number): Promise<Response<Array<Entity.Account>>>
  // ======================================
  // accounts/tags
  // ======================================
  /**
   * Show a hashtag and its associated information
   *
   * @param id Target hashtag id.
   * @return Tag
   */
  getTag(id: string): Promise<Response<Entity.Tag>>
  /**
   * Follow a hashtag. Posts containing a followed hashtag will be inserted into your home timeline.
   *
   * @param id Target hashtag id.
   * @return Tag
   */
  followTag(id: string): Promise<Response<Entity.Tag>>
  /**
   * Unfollow a hashtag. Posts containing this hashtag will no longer be inserted into your home timeline.
   *
   * @param id Target hashtag id.
   * @return Tag
   */
  unfollowTag(id: string): Promise<Response<Entity.Tag>>
  // ======================================
  // statuses
  // ======================================
  /**
   * Publish a status with the given parameters.
   *
   * @param status Text content of status.
   * @param options.media_ids Array of Attachment ids.
   * @param options.poll Poll object.
   * @param options.in_reply_to_id ID of the status being replied to, if status is a reply.
   * @param options.sensitive Mark status and attached media as sensitive?
   * @param options.spoiler_text Text to be shown as a warning or subject before the actual content.
   * @param options.visibility Visibility of the posted status.
   * @param options.scheduled_at ISO 8601 Datetime at which to schedule a status.
   * @param options.language ISO 639 language code for this status.
   * @param options.quote_id ID of the status being quoted to, if status is a quote.
   * @return Status. When options.scheduled_at is present, ScheduledStatus is returned instead.
   */
  postStatus(
    status: string,
    options?: {
      media_ids?: Array<string>
      poll?: { options: Array<string>; expires_in: number; multiple?: boolean; hide_totals?: boolean }
      in_reply_to_id?: string
      sensitive?: boolean
      spoiler_text?: string
      visibility?: 'public' | 'unlisted' | 'private' | 'direct'
      scheduled_at?: string
      language?: string
      quote_id?: string
    }
  ): Promise<Response<Entity.Status | Entity.ScheduledStatus>>
  /**
   * Obtain information about a status.
   *
   * @param id The target status id.
   * @return Status
   */
  getStatus(id: string): Promise<Response<Entity.Status>>
  /**
   * Edit a given status to change its text, sensitivity, media attachments, or poll. Note that editing a pollâ€™s options will reset the votes.
   *
   * @param id The target status id.
   * @param options.status Text context of status.
   * @param options.spoiler_text Text to be shown as a warning or subject before the actual content.
   * @param options.sensitive Mark status and attached media as sensitive?
   * @param options.media_ids Array of Attachment ids.
   * @param options.poll Poll object.
   * @return Status
   */
  editStatus(
    id: string,
    options: {
      status?: string
      spoiler_text?: string
      sensitive?: boolean
      media_ids?: Array<string>
      poll?: { options?: Array<string>; expires_in?: number; multiple?: boolean; hide_totals?: boolean }
    }
  ): Promise<Response<Entity.Status>>
  /**
   * Delete one of your own statuses.
   *
   * @param id The target status id.
   * @return Status
   */
  deleteStatus(id: string): Promise<Response<{}>>
  /**
   * Get parent and child statuses in context.
   * View statuses above and below this status in the thread.
   *
   * @param id The target status id.
   * @return Context
   */
  getStatusContext(id: string, options?: { limit?: number; max_id?: string; since_id?: string }): Promise<Response<Entity.Context>>
  /**
   * View status source.
   * Obtain the source properties for a status so that it can be edited.
   *
   * @param id The target status id.
   * @return StatusSource
   */
  getStatusSource(id: string): Promise<Response<Entity.StatusSource>>
  /**
   * See who boosted a status.
   *
   * @param id The target status id.
   * @return Array of accounts.
   */
  getStatusRebloggedBy(id: string): Promise<Response<Array<Entity.Account>>>
  /**
   * See who favourited a status
   *
   * @param id The target status id.
   * @return Array of accounts.
   */
  getStatusFavouritedBy(id: string): Promise<Response<Array<Entity.Account>>>
  /**
   * Favourite a status.
   *
   * @param id The target status id.
   * @return Status.
   */
  favouriteStatus(id: string): Promise<Response<Entity.Status>>
  /**
   * Undo favourite of a status.
   *
   * @param id The target status id.
   * @return Status.
   */
  unfavouriteStatus(id: string): Promise<Response<Entity.Status>>
  /**
   * Boost a status.
   *
   * @param id The target status id.
   * @return Status.
   */
  reblogStatus(id: string): Promise<Response<Entity.Status>>
  /**
   * Undo boost of a status.
   *
   * @param id The target status id.
   * @return Status.
   */
  unreblogStatus(id: string): Promise<Response<Entity.Status>>
  /**
   * Bookmark a status
   *
   * @param id The target status id.
   * @return Status.
   */
  bookmarkStatus(id: string): Promise<Response<Entity.Status>>
  /**
   * Undo bookmark of a status.
   *
   * @param id The target status id.
   * @return Status.
   */
  unbookmarkStatus(id: string): Promise<Response<Entity.Status>>
  /**
   * Mute a conversation.
   *
   * @param id The target status id.
   * @return Status
   */
  muteStatus(id: string): Promise<Response<Entity.Status>>
  /**
   * Unmute a conversation.
   *
   * @param id The target status id.
   * @return Status
   */
  unmuteStatus(id: string): Promise<Response<Entity.Status>>
  /**
   * Pin status to profile.
   *
   * @param id The target status id.
   * @return Status
   */
  pinStatus(id: string): Promise<Response<Entity.Status>>
  /**
   * Unpin status from profile.
   *
   * @param id The target status id.
   * @return Status
   */
  unpinStatus(id: string): Promise<Response<Entity.Status>>
  // ======================================
  // statuses/media
  // ======================================
  /**
   * Upload media as an attachment.
   *
   * @param file The file to be attached, using multipart form data.
   * @param options.description A plain-text description of the media.
   * @param options.focus Two floating points (x,y), comma-delimited, ranging from -1.0 to 1.0.
   * @return Attachment
   */
  uploadMedia(file: any, options?: { description?: string; focus?: string }): Promise<Response<Entity.Attachment | Entity.AsyncAttachment>>
  /**
   * Get media attachment.
   *
   * @param id Target media ID.
   * @return Attachment
   */
  getMedia(id: string): Promise<Response<Entity.Attachment>>
  /**
   * Update media attachment.
   *
   * @param id Target media ID.
   * @param options.file The file to be attached, using multipart form data.
   * @param options.description A plain-text description of the media.
   * @param options.focus Two floating points (x,y), comma-delimited, ranging from -1.0 to 1.0.
   * @param options.is_sensitive Whether the media is sensitive.
   * @return Attachment
   */
  updateMedia(
    id: string,
    options?: {
      file?: any
      description?: string
      focus?: string
      is_sensitive?: boolean
    }
  ): Promise<Response<Entity.Attachment>>
  // ======================================
  // statuses/polls
  // ======================================
  /**
   * View a poll.
   *
   * @param id Target poll ID.
   * @return Poll
   */
  getPoll(id: string): Promise<Response<Entity.Poll>>
  /**
   * Vote on a poll.
   *
   * @param id Target poll ID.
   * @param choices Array of own votes containing index for each option (starting from 0).
   * @return Poll
   */
  votePoll(id: string, choices: Array<number>, status_id?: string | null): Promise<Response<Entity.Poll>>
  // ======================================
  // statuses/scheduled_statuses
  // ======================================
  /**
   * View scheduled statuses.
   *
   * @param options.limit Max number of results to return. Defaults to 20.
   * @param options.max_id Return results older than ID.
   * @param options.since_id Return results newer than ID.
   * @param options.min_id Return results immediately newer than ID.
   * @return Array of scheduled statuses.
   */
  getScheduledStatuses(options?: {
    limit?: number
    max_id?: string
    since_id?: string
    min_id?: string
  }): Promise<Response<Array<Entity.ScheduledStatus>>>
  /**
   * View a single scheduled status.
   *
   * @param id Target status ID.
   * @return ScheduledStatus.
   */
  getScheduledStatus(id: string): Promise<Response<Entity.ScheduledStatus>>
  /**
   * Update a scheduled statusâ€™s publishing date.
   *
   * @param id Target scheduled status ID.
   * @param scheduled_at ISO 8601 Datetime at which the status will be published.
   * @return ScheduledStatus.
   */
  scheduleStatus(id: string, scheduled_at?: string | null): Promise<Response<Entity.ScheduledStatus>>
  /**
   * Cancel a scheduled status.
   *
   * @param id Target scheduled status ID.
   */
  cancelScheduledStatus(id: string): Promise<Response<{}>>
  // ======================================
  // timelines
  // ======================================
  /**
   * View public timeline.
   *
   * @param options.only_media Show only statuses with media attached? Defaults to false.
   * @param options.limit Max number of results to return. Defaults to 20.
   * @param options.max_id Return results older than ID.
   * @param options.since_id Return results newer than ID.
   * @param options.min_id Return results immediately newer than ID.
   * @return Array of statuses.
   */
  getPublicTimeline(options?: {
    only_media?: boolean
    limit?: number
    max_id?: string
    since_id?: string
    min_id?: string
  }): Promise<Response<Array<Entity.Status>>>
  /**
   * View local timeline.
   *
   * @param options.only_media Show only statuses with media attached? Defaults to false.
   * @param options.limit Max number of results to return. Defaults to 20.
   * @param options.max_id Return results older than ID.
   * @param options.since_id Return results newer than ID.
   * @param options.min_id Return results immediately newer than ID.
   * @return Array of statuses.
   */
  getLocalTimeline(options?: {
    only_media?: boolean
    limit?: number
    max_id?: string
    since_id?: string
    min_id?: string
  }): Promise<Response<Array<Entity.Status>>>
  /**
   * View hashtag timeline.
   *
   * @param hashtag Content of a #hashtag, not including # symbol.
   * @param options.local Show only local statuses? Defaults to false.
   * @param options.only_media Show only statuses with media attached? Defaults to false.
   * @param options.limit Max number of results to return. Defaults to 20.
   * @param options.max_id Return results older than ID.
   * @param options.since_id Return results newer than ID.
   * @param options.min_id Return results immediately newer than ID.
   * @return Array of statuses.
   */
  getTagTimeline(
    hashtag: string,
    options?: {
      local?: boolean
      only_media?: boolean
      limit?: number
      max_id?: string
      since_id?: string
      min_id?: string
    }
  ): Promise<Response<Array<Entity.Status>>>
  /**
   * View home timeline.
   *
   * @param options.local Show only local statuses? Defaults to false.
   * @param options.limit Max number of results to return. Defaults to 20.
   * @param options.max_id Return results older than ID.
   * @param options.since_id Return results newer than ID.
   * @param options.min_id Return results immediately newer than ID.
   * @return Array of statuses.
   */
  getHomeTimeline(options?: {
    local?: boolean
    limit?: number
    max_id?: string
    since_id?: string
    min_id?: string
  }): Promise<Response<Array<Entity.Status>>>
  /**
   * View list timeline.
   *
   * @param list_id Local ID of the list in the database.
   * @param options.limit Max number of results to return. Defaults to 20.
   * @param options.max_id Return results older than ID.
   * @param options.since_id Return results newer than ID.
   * @param options.min_id Return results immediately newer than ID.
   * @return Array of statuses.
   */
  getListTimeline(
    list_id: string,
    options?: {
      limit?: number
      max_id?: string
      since_id?: string
      min_id?: string
    }
  ): Promise<Response<Array<Entity.Status>>>
  // ======================================
  // timelines/conversations
  // ======================================
  /**
   * View all conversations.
   *
   * @param options.limit Max number of results to return. Defaults to 20.
   * @param options.max_id Return results older than ID.
   * @param options.since_id Return results newer than ID.
   * @param options.min_id Return results immediately newer than ID.
   * @return Array of statuses.
   */
  getConversationTimeline(options?: {
    limit?: number
    max_id?: string
    since_id?: string
    min_id?: string
  }): Promise<Response<Array<Entity.Conversation>>>
  /**
   * Remove a conversation.
   *
   * @param id Target conversation ID.
   */
  deleteConversation(id: string): Promise<Response<{}>>
  /**
   * Mark a conversation as read.
   *
   * @param id Target conversation ID.
   * @return Conversation.
   */
  readConversation(id: string): Promise<Response<Entity.Conversation>>
  // ======================================
  // timelines/lists
  // ======================================
  /**
   * View your lists.
   *
   * @return Array of lists.
   */
  getLists(): Promise<Response<Array<Entity.List>>>
  /**
   * Show a single list.
   *
   * @param id Target list ID.
   * @return List.
   */
  getList(id: string): Promise<Response<Entity.List>>
  /**
   * Create a list.
   *
   * @param title List name.
   * @return List.
   */
  createList(title: string): Promise<Response<Entity.List>>
  /**
   * Update a list.
   *
   * @param id Target list ID.
   * @param title New list name.
   * @return List.
   */
  updateList(id: string, title: string): Promise<Response<Entity.List>>
  /**
   * Delete a list.
   *
   * @param id Target list ID.
   */
  deleteList(id: string): Promise<Response<{}>>
  /**
   * View accounts in a list.
   *
   * @param id Target list ID.
   * @param options.limit Max number of results to return.
   * @param options.max_id Return results older than ID.
   * @param options.since_id Return results newer than ID.
   * @param options.min_id Return results immediately newer than ID.
   * @return Array of accounts.
   */
  getAccountsInList(
    id: string,
    options?: {
      limit?: number
      max_id?: string
      since_id?: string
    }
  ): Promise<Response<Array<Entity.Account>>>
  /**
   * Add accounts to a list.
   *
   * @param id Target list ID.
   * @param account_ids Array of account IDs to add to the list.
   */
  addAccountsToList(id: string, account_ids: Array<string>): Promise<Response<{}>>
  /**
   * Remove accounts from list.
   *
   * @param id Target list ID.
   * @param account_ids Array of account IDs to add to the list.
   */
  deleteAccountsFromList(id: string, account_ids: Array<string>): Promise<Response<{}>>
  // ======================================
  // timelines/markers
  // ======================================
  /**
   * Get saved timeline positions.
   *
   * @param timelines Array of timeline names, String enum anyOf home, notifications.
   * @return Marker or empty object.
   */
  getMarkers(timeline: Array<string>): Promise<Response<Entity.Marker | Record<never, never>>>
  /**
   * Save your position in a timeline.
   *
   * @param options.home Marker position of the last read status ID in home timeline.
   * @param options.notifications Marker position of the last read notification ID in notifications.
   * @return Marker.
   */
  saveMarkers(options?: { home?: { last_read_id: string }; notifications?: { last_read_id: string } }): Promise<Response<Entity.Marker>>
  // ======================================
  // notifications
  // ======================================
  /**
   * Get all notifications.
   *
   * @param options.limit Max number of results to return. Defaults to 20.
   * @param options.max_id Return results older than ID.
   * @param options.since_id Return results newer than ID.
   * @param options.min_id Return results immediately newer than ID.
   * @param options.exclude_types Array of types to exclude.
   * @param options.account_id Return only notifications received from this account.
   * @return Array of notifications.
   */
  getNotifications(options?: {
    limit?: number
    max_id?: string
    since_id?: string
    min_id?: string
    exclude_types?: Array<Entity.NotificationType>
    account_id?: string
  }): Promise<Response<Array<Entity.Notification>>>
  /**
   * Get a single notification.
   *
   * @param id Target notification ID.
   * @return Notification.
   */
  getNotification(id: string): Promise<Response<Entity.Notification>>
  /**
   * Dismiss all notifications.
   */
  dismissNotifications(): Promise<Response<{}>>
  /**
   * Dismiss a single notification.
   *
   * @param id Target notification ID.
   */
  dismissNotification(id: string): Promise<Response<{}>>
  /**
   * Mark as read all unread notifications.
   *
   * @param id A single notification ID to read
   * @param max_id Read all notifications up to this ID
   * @return Array of notifications
   */
  readNotifications(options: { id?: string; max_id?: string }): Promise<Response<Entity.Notification | Array<Entity.Notification>>>
  // ======================================
  // notifications/push
  // ======================================
  /**
   * Subscribe to push notifications.
   *
   * @param subscription[endpoint] Endpoint URL that is called when a notification event occurs.
   * @param subscription[keys][p256dh] User agent public key. Base64 encoded string of public key of ECDH key using prime256v1 curve.
   * @param subscription[keys] Auth secret. Base64 encoded string of 16 bytes of random data.
   * @param data[alerts][follow] Receive follow notifications?
   * @param data[alerts][favourite] Receive favourite notifications?
   * @param data[alerts][reblog] Receive reblog notifictaions?
   * @param data[alerts][mention] Receive mention notifications?
   * @param data[alerts][poll] Receive poll notifications?
   * @return PushSubscription.
   */
  subscribePushNotification(
    subscription: { endpoint: string; keys: { p256dh: string; auth: string } },
    data?: { alerts: { follow?: boolean; favourite?: boolean; reblog?: boolean; mention?: boolean; poll?: boolean } } | null
  ): Promise<Response<Entity.PushSubscription>>
  /**
   * Get current subscription.
   *
   * @return PushSubscription.
   */
  getPushSubscription(): Promise<Response<Entity.PushSubscription>>
  /**
   * Change types of notifications.
   *
   * @param data[alerts][follow] Receive follow notifications?
   * @param data[alerts][favourite] Receive favourite notifications?
   * @param data[alerts][reblog] Receive reblog notifictaions?
   * @param data[alerts][mention] Receive mention notifications?
   * @param data[alerts][poll] Receive poll notifications?
   * @return PushSubscription.
   */
  updatePushSubscription(
    data?: { alerts: { follow?: boolean; favourite?: boolean; reblog?: boolean; mention?: boolean; poll?: boolean } } | null
  ): Promise<Response<Entity.PushSubscription>>
  /**
   * Remove current subscription.
   */
  deletePushSubscription(): Promise<Response<{}>>
  // ======================================
  // search
  // ======================================
  /**
   * Perform a search.
   *
   * @param q The search query.
   * @param options.type Enum of search target.
   * @param options.limit Maximum number of results to load, per type. Defaults to 20. Max 40.
   * @param options.max_id Return results older than this id.
   * @param options.min_id Return results immediately newer than this id.
   * @param options.resolve Attempt WebFinger lookup. Defaults to false.
   * @param options.following Only include accounts that the user is following. Defaults to false.
   * @param options.account_id If provided, statuses returned will be authored only by this account.
   * @param options.exclude_unreviewed Filter out unreviewed tags? Defaults to false.
   * @return Results.
   */
  search(
    q: string,
    options?: {
      type?: 'accounts' | 'hashtags' | 'statuses'
      limit?: number
      max_id?: string
      min_id?: string
      resolve?: boolean
      offset?: number
      following?: boolean
      account_id?: string
      exclude_unreviewed?: boolean
    }
  ): Promise<Response<Entity.Results>>

  // ======================================
  // instance
  // ======================================
  /**
   * View server information.
   */
  getInstance(): Promise<Response<Entity.Instance>>

  /**
   * List of connected domains.
   */
  getInstancePeers(): Promise<Response<Array<string>>>

  /**
   * Weekly activity.
   */
  getInstanceActivity(): Promise<Response<Array<Entity.Activity>>>

  // ======================================
  // instance/trends
  // ======================================
  /**
   * View trending tags.
   *
   * @param limit Maximum number of results to return. Defaults to 10.
   */
  getInstanceTrends(limit?: number | null): Promise<Response<Array<Entity.Tag>>>

  // ======================================
  // instance/directory
  // ======================================
  /**
   * View profile directory.
   *
   * @param options.limit How many accounts to load. Default 40.
   * @param options.offset How many accounts to skip before returning results. Default 0.
   * @param options.order Order of results.
   * @param options.local Only return local accounts.
   * @return Array of accounts.
   */
  getInstanceDirectory(options?: {
    limit?: number
    offset?: number
    order?: 'active' | 'new'
    local?: boolean
  }): Promise<Response<Array<Entity.Account>>>

  // ======================================
  // instance/custom_emojis
  // ======================================
  /**
   * View all custom emoji.
   *
   * @return Array of emojis.
   */
  getInstanceCustomEmojis(): Promise<Response<Array<Entity.Emoji>>>

  // ======================================
  // instance/announcements
  // ======================================
  /**
   * View all announcements.
   *
   * @return Array of announcements.
   */
  getInstanceAnnouncements(): Promise<Response<Array<Entity.Announcement>>>

  /**
   * Dismiss an announcement.
   *
   * @param id The ID of the Announcement in the database.
   */
  dismissInstanceAnnouncement(id: string): Promise<Response<Record<never, never>>>

  /**
   * Add a reaction to an announcement.
   *
   * @param id The ID of the Announcement in the database.
   * @param name Unicode emoji, or the shortcode of a custom emoji.
   */
  addReactionToAnnouncement(id: string, name: string): Promise<Response<Record<never, never>>>

  /**
   * Remove a reaction from an announcement.
   *
   * @param id The ID of the Announcement in the database.
   * @param name Unicode emoji, or the shortcode of a custom emoji.
   */
  removeReactionFromAnnouncement(id: string, name: string): Promise<Response<Record<never, never>>>

  // ======================================
  // Emoji reactions
  // ======================================
  /**
   * React to a post with a unicode emoji.
   *
   * @param id Target status ID.
   * @param emoji A unicode emoj.
   * @return Status.
   **/
  createEmojiReaction(id: string, emoji: string): Promise<Response<Entity.Status>>
  /**
   * Remove a reaction to a post with a unicode emoji.
   *
   * @param id Target status ID.
   * @param emoji A unicode emoji you want to remove.
   * @return Status.
   **/
  deleteEmojiReaction(id: string, emoji: string): Promise<Response<Entity.Status>>
  /**
   * Get an object of emoji to account mappings with accounts that reacted to the post.
   *
   * @param id Target status ID.
   * @return Array of reaction.
   **/
  getEmojiReactions(id: string): Promise<Response<Array<Entity.Reaction>>>
  /**
   * Get an object of emoji to account mappings with accounts that reacted to the post for a specific emoji.
   *
   * @param id Target status ID.
   * @param emoji A unicode emoji.
   * @return Reaction.
   **/
  getEmojiReaction(id: string, emoji: string): Promise<Response<Entity.Reaction>>

  // ======================================
  // WebSocket
  // ======================================
  userSocket(): WebSocketInterface
  publicSocket(): WebSocketInterface
  localSocket(): WebSocketInterface
  tagSocket(tag: string): WebSocketInterface
  listSocket(list_id: string): WebSocketInterface
  directSocket(): WebSocketInterface
}

export class NoImplementedError extends Error {
  constructor(err?: string) {
    super(err)

    this.name = new.target.name
    Object.setPrototypeOf(this, new.target.prototype)
  }
}

export class ArgumentError extends Error {
  constructor(err?: string) {
    super(err)

    this.name = new.target.name
    Object.setPrototypeOf(this, new.target.prototype)
  }
}

export class UnexpectedError extends Error {
  constructor(err?: string) {
    super(err)

    this.name = new.target.name
    Object.setPrototypeOf(this, new.target.prototype)
  }
}

export class NodeinfoError extends Error {
  constructor(err?: string) {
    super(err)

    this.name = new.target.name
    Object.setPrototypeOf(this, new.target.prototype)
  }
}

/**
 * Get client for each SNS according to megalodon interface.
 *
 * @param sns Name of your SNS, `mastodon` or `pleroma`.
 * @param baseUrl hostname or base URL.
 * @param accessToken access token from OAuth2 authorization
 * @param userAgent UserAgent is specified in header on request.
 * @param proxyConfig Proxy setting, or set false if don't use proxy.
 * @return Client instance for each SNS you specified.
 */
export const generator = (
  sns: 'mastodon' | 'pleroma' | 'friendica' | 'firefish',
  baseUrl: string,
  accessToken: string | null = null,
  userAgent: string | null = null,
  proxyConfig: ProxyConfig | false = false
): MegalodonInterface => {
  switch (sns) {
    case 'pleroma': {
      const pleroma = new Pleroma(baseUrl, accessToken, userAgent, proxyConfig)
      return pleroma
    }
    case 'friendica': {
      const friendica = new Friendica(baseUrl, accessToken, userAgent, proxyConfig)
      return friendica
    }
    case 'mastodon': {
      const mastodon = new Mastodon(baseUrl, accessToken, userAgent, proxyConfig)
      return mastodon
    }
    case 'firefish': {
      const firefish = new Firefish(baseUrl, accessToken, userAgent, proxyConfig)
      return firefish
    }
  }
}
